name: ci
on:
  push:
    branches:
      - main # main 브랜치의 push 감지
jobs:
  build-and-push:
    runs-on: ubuntu-latest # github actions가 실행될 환경: github가 제공하는 가상 머신에서 실행된다
    steps:
      - name: Checkout Repository # Github actions 실행 환경에 git clone으로 현재 리포지토리의 코드 가져오기
        uses: actions/checkout@v2
        with:
          fetch-depth: 0 # 전체 Git 히스토리 가져옴

      - name: Set up JDK 17 # 자바 설치
        uses: actions/setup-java@v2
        with:
          java-version: '17'
          distribution: 'temurin' # 배포판 지정

      - name: Gradle Caching # 빌드 속도 향상을 위한 캐시 설정
        uses: actions/cache@v4 # Github actions에서 캐시를 저장하고 복원하는 기능. 이전에 저장된 캐시를 복원해 빌드 속도 향상
        with:
          path: | # 캐시 경로 지정 # 그래들이 다운로드한 라이브러리 및 빌드 캐시 / 그래들 래퍼 바이너리와 설정 파일
            ./${{ matrix.service }}/.gradle/caches
            ./${{ matrix.service }}/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('./**/*.gradle*', './**gradle-wrapper.properties')}} # 캐시 키 지정. build.gradle, gradle-wrapper.properties 등의 해시값을 기반으로 한 고유 값으로 키를 지정해 동일한 키가 존재하면 기존 캐시를 복원함. 변경되면 새로운 캐시 생성
          restore-keys: | # GitHub Actions가 실행될 때 캐시를 찾을 수 없으면, 유사한 캐시를 찾아 복원하도록 설정하는 옵션.
            ${{ runner.os }}-gradle-

      - name: Find merge base # git merge-base를 사용해 현재 main 브랜치와 원격 main 브랜치의 공통 조상 찾음. 변경사항 감지할 때 BASE_COMMIT을 기준으로 사용. # github actions 환경 변수에 공통 조상 저장
        run: |
          BASE_COMMIT=$(git merge-base main origin/main)
          echo "Comparing with: $BASE_COMMIT"
          echo "base_commit=$BASE_COMMIT" >> $GITHUB_ENV

      - name: Find changed files (compare with last merge base) # 마지막 공통 커밋 이후 변경사항 확인
        uses: Stockopedia/action-get-changed-files@v1 # 변경된 파일 감지 액션
        id: get_changed # get_changed에 쉼표로 구분된 형태로 변화된 모듈 저장
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # github api 인증(변경된 파일 목록 가져오기 위해 필요)
          base: "${{ env.base_commit }}"
          ignore: |
            "**/.github/**"
            "!**/.github/workflows/ci.yml"
          foldersOnly: true # 폴더 (모듈) 단위로 감지
          format: csv # 결과를 csv(쉽표로 구분된 문자열) 형식으로 출력

      - name: Echo changed files
        run: echo ${{ steps.get_changed.outputs.changed }}

      - name: Execute Gradle build # 변경된 모듈만 빌드
        run: |
          set -x
          
          cd common-module && ./gradlew clean && ./gradlew build && ls ./build/libs && cd ..
          
          for folder in $(echo ${{ steps.get_changed.outputs.changed }} | tr ',' '\n'); do
            if [ "$folder" == "common-module" ]; then
              continue;
            fi
          
            echo "Building in $folder..."
            if [ -f "$folder/Dockerfile" ]; then
              echo "Building gradle in $folder..."
              (cd "$folder" && ./gradlew build &&  ls ./build/libs)
            else
              echo "Dockerfile NOT FOUND in $folder"
            fi
          done

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker images # 변경된 모듈의 기존 이미지 존재 시 삭제 후 빌드
        run: |
          IFS=',' read -ra MODULES <<< "${{ steps.get_changed.outputs.changed }}"
          for module in "${MODULES[@]}"; do
            echo "Processing module: $module..."

            IMAGE_NAME="${{ secrets.DOCKER_USERNAME }}/${module}"
            TAG="${GITHUB_SHA::7}"
            TOKEN=$(curl -s -H "Content-Type: application/json" -X POST \
              -d '{"username": "'"${{ secrets.DOCKER_USERNAME }}"'", "password": "'"${{ secrets.DOCKER_PASSWORD }}"'"}' \
              https://hub.docker.com/v2/users/login/ | jq -r .token)

            EXISTS=$(curl -s -H "Authorization: JWT $TOKEN" \
              "https://hub.docker.com/v2/repositories/$IMAGE_NAME/tags/$TAG/" | jq -r '.count')

            if [[ "$EXISTS" -gt 0 ]]; then
              echo "Image $IMAGE_NAME:$TAG exists. Deleting..."
              curl -s -X DELETE -H "Authorization: JWT $TOKEN" \
                "https://hub.docker.com/v2/repositories/$IMAGE_NAME/tags/$TAG/"
              echo "Deleted existing image: $IMAGE_NAME:$TAG"
            else
              echo "No existing image found for $IMAGE_NAME:$TAG, proceeding with build..."
            fi

            if [ -f "$module/Dockerfile" ]; then
              echo "Building Docker image in $module..."
              docker build -t $IMAGE_NAME:$TAG ./$module
              docker push $IMAGE_NAME:$TAG
            else
              echo "Skipping $module (no Dockerfile found)"
            fi
          done